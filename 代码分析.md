# CodeAnalysis 类设计文档

## 概述
CodeAnalysis类用于分析Python项目目录结构，提取代码中的类和函数信息，构造知识图谱，并使用聚类算法分析代码社区结构。集成deepseek语言模型进行智能代码分析。

## 类设计

### 核心功能模块

#### 1. 文件扫描模块
```python
class CodeAnalysis:
    def __init__(self, project_path: str, deepseek_api_key: str):
        self.project_path = project_path
        self.deepseek_client = DeepSeekClient(api_key)
        self.graph = nx.Graph()
        self.code_elements = {}
        
    def scan_python_files(self) -> List[str]:
        """递归扫描项目目录，获取所有Python文件"""
        # 使用os.walk递归遍历目录
        # 过滤.py文件
        # 排除__pycache__等目录
```

#### 2. 代码解析模块
```python
    def parse_file(self, file_path: str) -> Dict:
        """解析单个Python文件，提取类和函数信息"""
        # 使用ast模块解析Python代码
        # 提取类定义、函数定义、导入语句
        # 分析函数调用关系
        
    def extract_classes(self, ast_node) -> List[Dict]:
        """提取类信息"""
        # 类名、方法列表、继承关系
        # 装饰器信息、文档字符串
        
    def extract_functions(self, ast_node) -> List[Dict]:
        """提取函数信息"""
        # 函数名、参数列表、返回类型
        # 调用的其他函数、装饰器
```

#### 3. 知识图谱构建模块
```python
    def build_knowledge_graph(self):
        """构建代码知识图谱"""
        # 节点：类、函数、模块
        # 边：继承关系、调用关系、导入关系
        
    def add_nodes(self, elements: List[Dict]):
        """添加节点到图中"""
        # 节点类型：class, function, module
        # 节点属性：name, type, file_path, complexity
        
    def add_edges(self, relationships: List[Dict]):
        """添加边到图中"""
        # 边类型：inherit, call, import, compose
        # 边权重：调用频率、耦合度
```

#### 4. 语言模型分析模块
```python
    def analyze_with_deepseek(self, code_snippet: str) -> Dict:
        """使用deepseek模型分析代码"""
        # 代码功能描述
        # 复杂度评估
        # 重构建议
        
    def semantic_analysis(self, elements: List[Dict]) -> Dict:
        """语义分析代码元素"""
        # 功能相似度分析
        # 命名规范检查
        # 代码质量评估
```

#### 5. 社区分析模块
```python
    def detect_communities(self, algorithm: str = 'louvain') -> Dict:
        """检测代码社区结构"""
        # 支持算法：louvain, girvan_newman, leiden
        # 返回社区划分结果
        
    def analyze_community_structure(self, communities: Dict) -> Dict:
        """分析社区结构特征"""
        # 社区内聚度、社区间耦合度
        # 关键节点识别
        # 架构建议
```

## 详细实现

### 1. 依赖库
```python
import os
import ast
import networkx as nx
from typing import List, Dict, Set
from community import community_louvain
from networkx.algorithms import community as nx_community
import matplotlib.pyplot as plt
import seaborn as sns
from openai import OpenAI  # 用于调用deepseek API
```

### 2. 核心数据结构
```python
# 代码元素结构
CodeElement = {
    'type': str,        # 'class', 'function', 'module'
    'name': str,        # 元素名称
    'file_path': str,   # 文件路径
    'line_number': int, # 行号
    'complexity': int,  # 复杂度
    'docstring': str,   # 文档字符串
    'dependencies': List[str],  # 依赖列表
    'semantic_info': Dict       # 语义信息
}

# 关系结构
Relationship = {
    'source': str,      # 源节点
    'target': str,      # 目标节点
    'type': str,        # 关系类型
    'weight': float,    # 权重
    'context': str      # 上下文信息
}
```

### 3. 主要方法实现

#### 文件扫描
```python
def scan_python_files(self) -> List[str]:
    python_files = []
    for root, dirs, files in os.walk(self.project_path):
        # 排除特定目录
        dirs[:] = [d for d in dirs if d not in ['__pycache__', '.git', 'venv']]
        for file in files:
            if file.endswith('.py'):
                python_files.append(os.path.join(root, file))
    return python_files
```

#### AST解析
```python
def parse_file(self, file_path: str) -> Dict:
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    tree = ast.parse(content)
    
    # 提取类和函数
    classes = self.extract_classes(tree)
    functions = self.extract_functions(tree)
    imports = self.extract_imports(tree)
    
    # 使用deepseek分析文件
    semantic_info = self.analyze_with_deepseek(content)
    
    return {
        'file_path': file_path,
        'classes': classes,
        'functions': functions,
        'imports': imports,
        'semantic_info': semantic_info
    }
```

#### 社区检测
```python
def detect_communities(self, algorithm: str = 'louvain') -> Dict:
    if algorithm == 'louvain':
        communities = community_louvain.best_partition(self.graph)
    elif algorithm == 'girvan_newman':
        communities = list(nx_community.girvan_newman(self.graph))
    elif algorithm == 'leiden':
        # 使用leiden算法
        pass
    
    # 分析社区特征
    community_stats = self.analyze_community_structure(communities)
    
    return {
        'communities': communities,
        'statistics': community_stats,
        'modularity': nx_community.modularity(self.graph, communities.values())
    }
```

### 4. DeepSeek集成
```python
class DeepSeekAnalyzer:
    def __init__(self, api_key: str):
        self.client = OpenAI(
            api_key=api_key,
            base_url="https://api.deepseek.com/v1"
        )
    
    def analyze_code_function(self, code: str) -> Dict:
        """分析代码功能"""
        prompt = f"""
        分析以下Python代码的功能和特征：
        {code}
        
        请从以下方面分析：
        1. 主要功能描述
        2. 复杂度评估（1-10分）
        3. 代码质量评估
        4. 重构建议
        5. 功能分类标签
        """
        
        response = self.client.chat.completions.create(
            model="deepseek-chat",
            messages=[{"role": "user", "content": prompt}]
        )
        
        return self.parse_analysis_response(response.choices[0].message.content)
    
    def classify_code_similarity(self, code1: str, code2: str) -> float:
        """计算代码语义相似度"""
        prompt = f"""
        比较以下两段代码的功能相似度（0-1分）：
        
        代码1：
        {code1}
        
        代码2：
        {code2}
        
        只返回相似度数值。
        """
        
        response = self.client.chat.completions.create(
            model="deepseek-chat",
            messages=[{"role": "user", "content": prompt}]
        )
        
        return float(response.choices[0].message.content.strip())
```

## 使用示例

### 基本使用
```python
# 初始化分析器
analyzer = CodeAnalysis(
    project_path="/path/to/python/project",
    deepseek_api_key="your_api_key"
)

# 执行分析
analyzer.analyze_project()

# 检测社区
communities = analyzer.detect_communities(algorithm='louvain')

# 可视化结果
analyzer.visualize_communities(communities)

# 生成报告
report = analyzer.generate_report()
```

### 高级功能
```python
# 自定义分析
analyzer.add_custom_metrics(['cyclomatic_complexity', 'maintainability_index'])

# 语义聚类
semantic_clusters = analyzer.cluster_by_semantics(threshold=0.7)

# 架构建议
architecture_advice = analyzer.get_architecture_suggestions()
```

## 输出格式

### 社区分析报告
```json
{
    "communities": {
        "community_0": {
            "nodes": ["ClassA", "FunctionB", "ModuleC"],
            "cohesion": 0.85,
            "size": 12,
            "main_functionality": "数据处理模块"
        }
    },
    "architecture_metrics": {
        "modularity": 0.72,
        "coupling": 0.34,
        "cohesion": 0.68
    },
    "recommendations": [
        "建议将community_1中的ClassX重构到独立模块",
        "community_2耦合度过高，需要解耦"
    ]
}
```

## 扩展功能

1. **可视化模块**：使用matplotlib/plotly绘制知识图谱
2. **报告生成**：自动生成分析报告
3. **持续集成**：集成到CI/CD流程
4. **Web界面**：提供Web交互界面
5. **插件系统**：支持自定义分析插件
